pipeline {
    agent any
    
    environment {
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '833371734412'
        ECR_REGISTRY = '833371734412.dkr.ecr.us-east-1.amazonaws.com'
        ECR_REPOSITORY = 'nginx-web-site'
        IMAGE_TAG = 'v1'
        CLUSTER_NAME = 'nginx-web-site-cluster'
        SERVICE_NAME = 'nginx-web-site-task-service-b2igefhw'
        TASK_FAMILY = 'nginx-web-site-task'
        
        // Terraform variables
        TF_VAR_aws_region = 'us-east-1'
        TF_VAR_environment = 'dev'
        TF_VAR_project_name = 'nginx-web-site'
        TF_VAR_aws_account_id = '833371734412'
    }

    stages {
        stage('Checkout') {
            steps {
                echo "üì• C√≥digo j√° est√° no workspace"
                echo "üìÅ Listando arquivos do projeto..."
                sh 'ls -la'
                sh 'ls -la terraform/ || echo "Diret√≥rio terraform n√£o encontrado"'
            }
        }
        
        stage('Terraform Init') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir('terraform') {
                        sh '''
                            echo "üîß Inicializando Terraform..."
                            terraform --version
                            terraform init
                            echo "‚úÖ Terraform inicializado!"
                        '''
                    }
                }
            }
        }
        
        stage('Terraform Plan') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir('terraform') {
                        sh '''
                            echo "üìã Executando Terraform Plan..."
                            terraform plan -out=tfplan
                            echo "‚úÖ Terraform Plan conclu√≠do!"
                        '''
                    }
                }
            }
        }
        
        stage('Terraform Apply - Approval') {
            steps {
                script {
                    echo "‚è∏Ô∏è Aguardando aprova√ß√£o para aplicar mudan√ßas na infraestrutura..."
                    input message: 'Aplicar mudan√ßas do Terraform na infraestrutura AWS?', 
                          ok: 'Aplicar',
                          submitterParameter: 'APPROVER'
                    echo "‚úÖ Aprova√ß√£o recebida de: ${env.APPROVER}"
                }
            }
        }
        
        stage('Terraform Apply') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir('terraform') {
                        sh '''
                            echo "üöÄ Aplicando mudan√ßas do Terraform..."
                            terraform apply tfplan
                            echo "‚úÖ Infraestrutura atualizada!"
                            
                            echo "üìä Recursos criados/atualizados:"
                            terraform output
                        '''
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                sh 'docker build -t ${ECR_REPOSITORY}:${IMAGE_TAG} .'
                sh 'docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}'
                echo "‚úÖ Imagem Docker criada"
            }
        }
        
        stage('Test Docker Image') {
            steps {
                sh '''
                    echo "üß™ Testando imagem Docker..."
                    docker run --rm -d --name test-nginx ${ECR_REPOSITORY}:${IMAGE_TAG}
                    sleep 5
                    CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' test-nginx)
                    echo "üîç Testando container no IP: $CONTAINER_IP"
                    curl -f http://$CONTAINER_IP || (docker logs test-nginx && docker stop test-nginx && exit 1)
                    docker stop test-nginx
                    echo "‚úÖ Teste da imagem passou!"
                '''
            }
        }
        
        stage('SonarQube Analysis') {
            steps {
                script {
                    def scannerHome = tool 'SonarQube Scanner'
                    withSonarQubeEnv('SonarQube') {
                        sh """
                            echo "üîç Iniciando an√°lise de qualidade de c√≥digo..."
                            echo "üìç Scanner path: ${scannerHome}"
                            ${scannerHome}/bin/sonar-scanner \\
                                -Dsonar.projectKey=nginx-web-site \\
                                -Dsonar.projectName="Nginx Web Site" \\
                                -Dsonar.projectVersion=1.0 \\
                                -Dsonar.sources=. \\
                                -Dsonar.exclusions="**/node_modules/**,**/target/**,**/.git/**,**/docker-compose.yml,**/terraform/.terraform/**,**/*.tfstate*,**/*.tfplan" \\
                                -Dsonar.inclusions="**/*.html,**/*.css,**/*.js,**/*.sh,**/Dockerfile,**/jenkinsfile,**/*.tf" \\
                                -Dsonar.sourceEncoding=UTF-8
                            echo "‚úÖ An√°lise SonarQube conclu√≠da!"
                        """
                    }
                }
            }
        }
        
        stage('Quality Gate') {
            steps {
                script {
                    echo "‚è≥ Aguardando resultado do Quality Gate..."
                    timeout(time: 10, unit: 'MINUTES') {
                        def qg = waitForQualityGate()
                        if (qg.status != 'OK') {
                            echo "‚ùå Quality Gate falhou: ${qg.status}"
                            echo "‚ö†Ô∏è Abortando deploy devido a problemas de qualidade de c√≥digo"
                            error "Pipeline abortada devido ao Quality Gate: ${qg.status}"
                        } else {
                            echo "‚úÖ Quality Gate passou! Prosseguindo com deploy..."
                        }
                    }
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        echo "üîë Fazendo login no ECR..."
                        aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        echo "üì§ Enviando imagem para ECR..."
                        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}
                        echo "‚úÖ Imagem enviada para ECR"
                    '''
                }
            }
        }
        
        stage('Deploy to Fargate') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        echo "üöÄ Atualizando aplica√ß√£o no Fargate..."
                        
                        # Criar nova task definition com a nova imagem
                        NEW_TASK_DEF=$(aws ecs register-task-definition \
                            --family ${TASK_FAMILY} \
                            --network-mode awsvpc \
                            --requires-compatibilities FARGATE \
                            --cpu 256 \
                            --memory 512 \
                            --execution-role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole" \
                            --task-role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole" \
                            --container-definitions '[{
                                "name": "nginx-container",
                                "image": "'${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}'",
                                "essential": true,
                                "portMappings": [{"containerPort": 80, "protocol": "tcp"}],
                                "logConfiguration": {
                                    "logDriver": "awslogs",
                                    "options": {
                                        "awslogs-group": "/ecs/nginx-web-site",
                                        "awslogs-create-group": "true",
                                        "awslogs-region": "'${AWS_REGION}'",
                                        "awslogs-stream-prefix": "ecs"
                                    }
                                }
                            }]' \
                            --region ${AWS_REGION} \
                            --query 'taskDefinition.taskDefinitionArn' \
                            --output text)
                        
                        echo "üìù Nova task definition: $NEW_TASK_DEF"
                        
                        # Atualizar o servi√ßo
                        aws ecs update-service \
                            --cluster ${CLUSTER_NAME} \
                            --service ${SERVICE_NAME} \
                            --task-definition "$NEW_TASK_DEF" \
                            --region ${AWS_REGION}
                        
                        echo "‚úÖ Servi√ßo atualizado! Aguardando deploy..."
                        
                        # Aguardar deploy completar
                        aws ecs wait services-stable \
                            --cluster ${CLUSTER_NAME} \
                            --services ${SERVICE_NAME} \
                            --region ${AWS_REGION}
                        
                        echo "üéâ Deploy conclu√≠do com sucesso!"
                        
                        # Mostrar URL da aplica√ß√£o com tratamento de erro melhorado
                        echo "üîç Buscando informa√ß√µes da aplica√ß√£o..."
                        sleep 10  # Aguardar task ficar completamente ativa
                        
                        TASK_ARN=$(aws ecs list-tasks --cluster ${CLUSTER_NAME} --service-name ${SERVICE_NAME} --region ${AWS_REGION} --query 'taskArns[0]' --output text 2>/dev/null)
                        
                        if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
                            echo "‚úÖ Task encontrada: $TASK_ARN"
                            
                            # Buscar ENI com tratamento de erro
                            ENI_ID=$(aws ecs describe-tasks --cluster ${CLUSTER_NAME} --tasks "$TASK_ARN" --region ${AWS_REGION} --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text 2>/dev/null || echo "")
                            
                            if [ ! -z "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                                echo "‚úÖ Network interface encontrada: $ENI_ID"
                                
                                # Buscar IP p√∫blico com tratamento de erro
                                PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --region ${AWS_REGION} --query 'NetworkInterfaces[0].Association.PublicIp' --output text 2>/dev/null || echo "")
                                
                                if [ ! -z "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
                                    echo "üåê Aplica√ß√£o dispon√≠vel em: http://$PUBLIC_IP"
                                    echo "‚úÖ Deploy finalizado com sucesso!"
                                else
                                    echo "‚ö†Ô∏è IP p√∫blico n√£o dispon√≠vel ainda"
                                    echo "üìã Verifique o console AWS ECS para obter o IP"
                                fi
                            else
                                echo "‚ö†Ô∏è Network interface n√£o encontrada ou ainda sendo configurada"
                                echo "üìã Verifique o console AWS ECS - a aplica√ß√£o pode estar inicializando"
                            fi
                        else
                            echo "‚ö†Ô∏è Nenhuma task ativa encontrada"
                            echo "üìã Verifique o console AWS ECS para status das tasks"
                        fi
                        
                        echo ""
                        echo "üìä Status do servi√ßo:"
                        aws ecs describe-services --cluster ${CLUSTER_NAME} --services ${SERVICE_NAME} --region ${AWS_REGION} --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' --output table || echo "Erro ao obter status"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh 'docker rmi ${ECR_REPOSITORY}:${IMAGE_TAG} || true'
            sh 'docker rmi ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} || true'
        }
        success { echo 'üéâ Pipeline executado com sucesso!' }
        failure { echo '‚ùå Pipeline falhou!' }
    }
}